# .NET Desktop
# Build and run tests for .NET Desktop or Windows classic desktop solutions.
# Add steps that publish symbols, save build artifacts, and more:
# https://docs.microsoft.com/azure/devops/pipelines/apps/windows/dot-net

trigger:
- master

pool:
  vmImage: 'windows-latest'

variables:
  solutionFolder: '$(Build.SourcesDirectory)/NavfertyExcelAddIn'
  solution: '$(Build.SourcesDirectory)/NavfertyExcelAddIn.slnx'
  buildPlatform: 'Any CPU'
  buildConfiguration: 'Release'

steps:
- task: NuGetToolInstaller@1

- task: NuGetCommand@2
  inputs:
    restoreSolution: '$(solution)'

# Remove Website project from solution to avoid .NET Framework 4.0 targeting pack error
- task: PowerShell@2
  displayName: 'Remove Website project from solution'
  inputs:
    targetType: 'inline'
    script: |
      $solutionFile = '$(solution)'
      $content = Get-Content $solutionFile -Raw
      $pattern = '(?s)\s*<Project Path="Website/".*?</Project>'
      $content = $content -replace $pattern, ''
      Set-Content $solutionFile $content -NoNewline
      Write-Host "Website project removed from solution"

- task: PowerShell@2
  name: 'ImportCertificate'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Import Certificate"
      $pfxpath = '$(solutionFolder)/$(certfile)'
      Add-Type -AssemblyName System.Security
      $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2
      $cert.Import($pfxpath, '$(password)', [System.Security.Cryptography.X509Certificates.X509KeyStorageFlags]"PersistKeySet")
      $store = new-object system.security.cryptography.X509Certificates.X509Store -argumentlist "MY", CurrentUser
      $store.Open([System.Security.Cryptography.X509Certificates.OpenFlags]"ReadWrite")
      $store.Add($cert)
      $store.Close()

- task: VSBuild@1
  inputs:
    solution: '$(solution)'
    vsVersion: 'latest'
    msbuildArchitecture: 'x64'
    platform: '$(buildPlatform)'
    configuration: '$(buildConfiguration)'

- task: PowerShell@2
  name: 'RunTests'
  displayName: 'Run TUnit Tests'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Finding TUnit test executable..."
      $testExe = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Recurse -Filter "*UnitTests.exe" | 
                 Where-Object { $_.FullName -like "*bin\$(buildConfiguration)*" } |
                 Select-Object -First 1
      
      if (-not $testExe) {
        Write-Error "Test executable not found"
        exit 1
      }
      
      Write-Host "Found test executable: $($testExe.FullName)"
      Write-Host "`nRunning tests (excluding Automation tests)..."
      
      $testResultsDir = "$(Build.SourcesDirectory)/TestResults"
      New-Item -ItemType Directory -Force -Path $testResultsDir | Out-Null
      
      # Run TUnit tests with TRX output, excluding Automation category
      & $testExe.FullName --report-trx --results-directory $testResultsDir --treenode-filter "/**[Category!=Automation]"
      
      $exitCode = $LASTEXITCODE
      Write-Host "Test execution completed with exit code: $exitCode"
      
      if ($exitCode -ne 0) {
        Write-Warning "Tests failed with exit code $exitCode"
        exit $exitCode
      }
    workingDirectory: '$(Build.SourcesDirectory)'

- task: PowerShell@2
  name: 'CollectCodeCoverage'
  displayName: 'Collect Code Coverage'
  inputs:
    targetType: 'inline'
    script: |
      Write-Host "Installing tools..."
      dotnet tool install dotnet-coverage --tool-path . --ignore-failed-sources
      dotnet tool install dotnet-reportgenerator-globaltool --tool-path . --ignore-failed-sources
      
      Write-Host "`nCreating reports directory..."
      New-Item -ItemType Directory -Force -Path .\reports | Out-Null
      
      Write-Host "`nFinding TUnit test executable..."
      $testExe = Get-ChildItem -Path "$(Build.SourcesDirectory)" -Recurse -Filter "*UnitTests.exe" | 
                 Where-Object { $_.FullName -like "*bin\$(buildConfiguration)*" } |
                 Select-Object -First 1
      
      if (-not $testExe) {
        Write-Error "Test executable not found"
        exit 1
      }
      
      Write-Host "Found test executable: $($testExe.FullName)"
      Write-Host "`nRunning tests with code coverage (excluding Automation tests)..."
      
      $testResultsDir = "$(Build.SourcesDirectory)/TestResults"
      New-Item -ItemType Directory -Force -Path $testResultsDir | Out-Null
      
      # Run tests with dotnet-coverage, excluding Automation category
      & "$(Build.SourcesDirectory)\dotnet-coverage.exe" collect `
        --output "$(Build.SourcesDirectory)\coverage.cobertura.xml" `
        --output-format cobertura `
        $testExe.FullName --report-trx --results-directory $testResultsDir --treenode-filter "/**[Category!=Automation]"
      
      Write-Host "`nGenerating coverage report..."
      if (Test-Path "$(Build.SourcesDirectory)\coverage.cobertura.xml") {
        & "$(Build.SourcesDirectory)\reportgenerator.exe" `
          "-reports:$(Build.SourcesDirectory)\coverage.cobertura.xml" `
          "-targetdir:$(Build.SourcesDirectory)\reports" `
          "-reporttypes:HTMLInline;HTMLChart"
        Write-Host "Coverage report generated successfully"
      } else {
        Write-Warning "No coverage file found"
      }
    workingDirectory: '$(Build.SourcesDirectory)'

- task: PublishTestResults@2
  displayName: 'Publish Test Results'
  condition: always()
  inputs:
    testResultsFormat: 'VSTest'
    testResultsFiles: '**/*.trx'
    searchFolder: '$(Build.SourcesDirectory)/TestResults'
    mergeTestResults: true
    failTaskOnFailedTests: false
    testRunTitle: 'Unit Tests'

- task: PublishCodeCoverageResults@2
  inputs:
    codeCoverageTool: 'Cobertura'
    summaryFileLocation: '$(Build.SourcesDirectory)/coverage.cobertura.xml'
